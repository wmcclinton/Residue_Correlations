/*
 * Copyright 2016 Ahnaf Siddiqui, Mohsen Botlani and Sameer Varma
 *
 * This program uses the GROMACS molecular simulation package API.
 * Copyright (c) 1991-2000, University of Groningen, The Netherlands.
 * Copyright (c) 2001-2004, The GROMACS development team.
 * Copyright (c) 2013,2014, by the GROMACS development team, led by
 * Mark Abraham, David van der Spoel, Berk Hess, and Erik Lindahl,
 * and including many others, as listed at http://www.gromacs.org.

 * g_ensemble_comp quantifies the difference between two conformational ensembles (two trajectory files)
 * Quantification is in terms of a true metric, eta=1-Overlap
 * Leighty and Varma, Quantifying Changes in Intrinsic Molecular Motion Using Support Vector Machines, J. Chem. Theory Comput. 2013, 9, 868-875.
 */

#include "ensemble_res_comp.h"
#include "gkut_io.h"
#include "gkut_log.h"

#ifdef _OPENMP
#include <omp.h>
#endif

static void free_svm_model(struct svm_model *model);

// TODO: Does this work for gro files generated by grompp etc?
static void res_tpx(eta_res_dat_t *eta_dat, t_atoms *atoms) {
    t_inputrec ir;
    gmx_mtop_t mtop;
    matrix box;
    int natoms;
    int i;

    read_tpx(eta_dat->fnames[eRES1], &ir, box, &natoms, NULL, NULL, NULL, &mtop);

    *atoms = mtop.moltype->atoms;
    // TODO: free the rest of the mtop?

    ///
    snew(eta_dat->res_IDs, atoms->nres);
    snew(eta_dat->res_names, atoms->nres);
    snew(eta_dat->res_natoms, atoms->nres);

    eta_dat->nres = atoms->nres;
    
    // Only sum the atoms that are in the indexes in atom_IDs
    int resid;
    for (int i = 0; i < natoms; ++i) {
        resid = atoms->atom[eta_dat->atom_IDs[i]].resind;
        eta_dat->res_natoms[resid] += 1;
    }

    for (int i = 0; i < atoms->nres; ++i) {
        eta_dat->res_IDs[i] = atoms->resinfo[i].nr;
        eta_dat->res_names[i] = *(atoms->resinfo[i].name);
    }

    // Set eta_data natoms = natoms in tpr file
    eta_dat->natoms = natoms;
}


void init_eta_dat(eta_res_dat_t *eta_dat) {
    eta_dat->gamma = GAMMA;
    eta_dat->c = COST;
    eta_dat->nthreads = -1;
    eta_dat->oenv = NULL;

    eta_dat->nres = 0;
    eta_dat->res_IDs = NULL;
    eta_dat->res_names = NULL;
    eta_dat->res_natoms = NULL;
    eta_dat->eta = NULL;

    eta_dat->natoms_all = 0;

    eta_dat->DOT = 1;
    eta_dat->STD = 1;
}

void free_eta_dat(eta_res_dat_t *eta_dat) {
    if (eta_dat->res_IDs)    sfree(eta_dat->res_IDs);
    if (eta_dat->res_names)  sfree(eta_dat->res_names);
    if (eta_dat->res_natoms) sfree(eta_dat->res_natoms);
    if (eta_dat->eta)        sfree(eta_dat->eta);
}

////////////////////////////////////////
void calc_correlations(eta_res_dat_t *eta_dat) {
    const char *io_error = "Input trajectory files must be .xtc, .trr, or .pdb!\n";
    const char *fr_error = "Input trajectories have differing numbers of frames!\n";
    const char *ndx_error = "Given index groups have differing numbers of atoms!\n";
    const char *natom_error = "Input trajectories have differing numbers of atoms!\n";

    /* Trajectory data */
    rvec **x1; // Trajectory position vectors
    int nframes, i;

    /* Read trajectory files */
    matrix *box = NULL;
    switch(fn2ftp(eta_dat->fnames[eTRAJ1])) {
        case efXTC:
        case efTRR:
        case efPDB:
            gk_read_traj(eta_dat->fnames[eTRAJ1], &x1, &box, &nframes, &eta_dat->natoms, &eta_dat->oenv);
            break;
        default:
            gk_log_fatal(FARGS, io_error);
    }
    sfree(box); // don't need box data
    box = NULL;

    // Save total natoms before it is potentially changed by index data below.
    // Might be needed, for example, by residue reading functions. */
    eta_dat->natoms_all = eta_dat->natoms;

    /* Index data */
    const int NUMGROUPS = 1;
    int *isize;
    atom_id **indx1; // Atom indices for the two trajectories
    char **grp_names;

    snew(isize, NUMGROUPS);
    snew(indx1, NUMGROUPS);
    snew(grp_names, NUMGROUPS);

    snew(indx1[0], eta_dat->natoms);
    for (i = 0; i < eta_dat->natoms; ++i) {
        indx1[0][i] = i;
    }

    eta_dat->atom_IDs = indx1[0]; // store atom IDs in output

    // Get residue information
    t_atoms atoms;
    gk_print_log("Reading residue info from %s...\n", eta_dat->fnames[eRES1]);
    switch(fn2ftp(eta_dat->fnames[eRES1])) {
        case efTPR:
            res_tpx(eta_dat, &atoms);
            break;
        default:
            gk_log_fatal(FARGS, "%s is not a supported filetype for residue information. Skipping eta residue calculation.\n",
                eta_dat->fnames[eRES1]);
            //flush_log();
    }

    //atom_printer(eta_dat, x1, 1, &atoms);
    calc_corr_matrix(eta_dat, x1, nframes, &atoms);
        
}

void atom_printer(eta_res_dat_t *eta_dat,
    rvec **x1,
    int nframes,
    t_atoms *atoms){   

    /////////////////////////////////////////////////////////
    // Build map from residue IDs to atom IDs
    // TODO: make this more efficient
    int **res_atoms = NULL;
    int *res_atom_lens = NULL;
    snew(res_atoms, atoms->nres);
    snew(res_atom_lens, atoms->nres);
    for (int atom = 0; atom < atoms->nr; ++atom) {
      int resind = atoms->atom[atom].resind;
      // allocate memory for another atom for this atom's residue
      if (res_atom_lens[resind] == 0) {
        snew(res_atoms[resind], 1);
      } else {
        srenew(res_atoms[resind], res_atom_lens[resind] + 1);
      }
      // add this atom to this atom's residue
      res_atoms[resind][res_atom_lens[resind]] = atom;
      ++res_atom_lens[resind];
    }
    
    for (int cur_res = 0; cur_res < eta_dat->nres; ++cur_res) {
        printf("Residue %d...\r", cur_res);
        fflush(stdout);
        for (int cur_frame = 0; cur_frame < nframes; ++cur_frame) {
            for (int i = 0; i < res_atom_lens[cur_res]; ++i) {
                int atomid = res_atoms[cur_res][i];
                for (int coord = 0; coord < 3; ++coord) {
                    printf("Atom - %d - %d - %d: %f Mass: %f\n", cur_frame, atomid, coord, x1[cur_frame][atomid][coord] * 10.0, atoms->atom[atomid].m);
                }
            }
        }
    }
}

void calc_corr_matrix(eta_res_dat_t *eta_dat,
    rvec **x1,
    int nframes,
    t_atoms *atoms)
{   
    /////////////////////////////////////////////////////////
    // Build map from residue IDs to atom IDs
    // TODO: make this more efficient
    int **res_atoms = NULL;
    int *res_atom_lens = NULL;
    snew(res_atoms, atoms->nres);
    snew(res_atom_lens, atoms->nres);
    for (int atom = 0; atom < atoms->nr; ++atom) {
      int resind = atoms->atom[atom].resind;
      // allocate memory for another atom for this atom's residue
      if (res_atom_lens[resind] == 0) {
        snew(res_atoms[resind], 1);
      } else {
        srenew(res_atoms[resind], res_atom_lens[resind] + 1);
      }
      // add this atom to this atom's residue
      res_atoms[resind][res_atom_lens[resind]] = atom;
      ++res_atom_lens[resind];
    }

    ///////////////////////////////////////////////////
    // Calculates the center of masses of the residues
    real ***res_f_cmass = NULL;
    snew(res_f_cmass, nframes);
    for (int cur_frame = 0; cur_frame < nframes; ++cur_frame) {
        snew(res_f_cmass[cur_frame], atoms->nres);
        for (int cur_res = 0; cur_res < eta_dat->nres; ++cur_res) {
            snew(res_f_cmass[cur_frame][cur_res], 3);
        }
    }
    real **res_cmass = NULL;
    snew(res_cmass, atoms->nres);
    for (int cur_res = 0; cur_res < eta_dat->nres; ++cur_res) {
        snew(res_cmass[cur_res], 3);
    }

    real **stddev = NULL;
    snew(stddev, atoms->nres);
    for (int cur_res = 0; cur_res < eta_dat->nres; ++cur_res) {
        snew(stddev[cur_res], 3);
    }

    for (int cur_frame = 0; cur_frame < nframes; ++cur_frame) {
        for (int cur_res = 0; cur_res < eta_dat->nres; ++cur_res) {
            for (int coord = 0; coord < 3; ++coord) {   
                real total_mass = 0;
                real massxdisp = 0;
                for (int i = 0; i < res_atom_lens[cur_res]; ++i) {
                    int atomid = res_atoms[cur_res][i];
                    total_mass += atoms->atom[atomid].m;
                    massxdisp += x1[cur_frame][atomid][coord] * 10.0 * atoms->atom[atomid].m;    
                }
                res_f_cmass[cur_frame][cur_res][coord] = massxdisp/total_mass;
                res_cmass[cur_res][coord] += massxdisp/total_mass;
            }
        } 
    }

    for (int cur_res = 0; cur_res < eta_dat->nres; ++cur_res) {
        for (int coord = 0; coord < 3; ++coord) {
            res_cmass[cur_res][coord] = res_cmass[cur_res][coord] / nframes;
            //printf("Check %d - %d: %f\n", cur_res, coord, res_cmass[cur_res][coord]);
        }
    }

    // Calulate stddev
    for (int cur_res = 0; cur_res < eta_dat->nres; ++cur_res) {
        for (int coord = 0; coord < 3; ++coord) {
            stddev[cur_res][coord] = 0;
            for (int cur_frame = 0; cur_frame < nframes; ++cur_frame) {
                stddev[cur_res][coord] += pow(res_f_cmass[cur_frame][cur_res][coord] - res_cmass[cur_res][coord],2);
            }
            stddev[cur_res][coord] = sqrt(stddev[cur_res][coord]) / nframes;
        }
    }

    // Calculate Coorelation
    real **res_correlation = NULL;
    snew(res_correlation, atoms->nres);
    for (int cur_res = 0; cur_res < eta_dat->nres; ++cur_res) {
        snew(res_correlation[cur_res], atoms->nres);
    }

    for (int cur_res = 0; cur_res < eta_dat->nres; ++cur_res) {
        for (int cur_res2 = 0; cur_res2 < eta_dat->nres; ++cur_res2) {
            printf("\rCalculating correlation between residue %d and %d", cur_res, cur_res2);
            fflush(stdout);
            real correlation = 0;
            real distance = 0;
            real distance2 = 0;
            for (int cur_frame = 0; cur_frame < nframes; ++cur_frame) {
                distance = 0;
                distance2 = 0;
                // Calculate (f-[f])*(g-[g])
                if(eta_dat->DOT == 0)
                {
                    for (int coord = 0; coord < 3; ++coord) {
                        distance += pow(res_f_cmass[cur_frame][cur_res][coord] - res_cmass[cur_res][coord],2);
                        distance2 += pow(res_f_cmass[cur_frame][cur_res2][coord] - res_cmass[cur_res2][coord],2);
                    }
                    distance = sqrt(distance);
                    distance2 = sqrt(distance2);
                }
                else
                {
                    for (int coord = 0; coord < 3; ++coord) {
                        distance += (res_f_cmass[cur_frame][cur_res][coord] - res_cmass[cur_res][coord])*(res_f_cmass[cur_frame][cur_res2][coord] - res_cmass[cur_res2][coord]);
                    }
                    distance2 = 1;
                }
                
                correlation += fabsf(distance*distance2);
            }

            // Calculate Sigma f * Sigma g
            real sigfsigG = 0;
            for (int coord = 0; coord < 3; ++coord) {
                sigfsigG += stddev[cur_res][coord] * stddev[cur_res2][coord];
            }

            if(eta_dat->STD == 1)
            {
                correlation = correlation/(sigfsigG);
                correlation = correlation/pow(nframes,2);
            }

            ///*Assign the part of the Matrix*/ = correlation
            res_correlation[cur_res][cur_res2] = correlation;
        }
    }

    printf("\n#Results#\n\n");

    if(eta_dat->STD == 1)
    {
        for (int cur_res = 0; cur_res < 20; ++cur_res) {
            for (int cur_res2 = 0; cur_res2 < 20; ++cur_res2) {
                if(1){
                    printf("%.2f", res_correlation[cur_res][cur_res2]);
                }
                printf(", ");
            }
            printf("\n\n");
        }
    }
    else
    {
        for (int cur_res = 0; cur_res < eta_dat->nres; ++cur_res) {
            for (int cur_res2 = 0; cur_res2 < eta_dat->nres; ++cur_res2) {
                if(1){
                    printf("%d-%d\t%.3f\n", cur_res, cur_res2, res_correlation[cur_res][cur_res2]);
                }
            }
        }
    }
}